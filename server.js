const express = require("express");
const { MongoClient, ObjectId } = require("mongodb");
const axios = require("axios");
const path = require("path");
require("dotenv").config();

const app = express();
const port = process.env.PORT || 5000;
const mongoUri = process.env.MONGO_URI;
const openWeatherKey = process.env.OPENWEATHER_API_KEY;

let db;

app.use(express.json());
app.use(express.static(path.join(__dirname, "client")));

// Debug: Log the Mongo URI to verify it loads correctly.
console.log("ðŸ§ª MONGO_URI:", mongoUri);

// Connect to MongoDB Atlas
MongoClient.connect(mongoUri, { useUnifiedTopology: true })
  .then(client => {
    console.log("âœ… Connected to MongoDB Atlas");
    db = client.db(); // Database name is specified in the URI
    app.listen(port, () => {
      console.log(`ðŸš€ Server running on http://localhost:${port}`);
    });
  })
  .catch(err => console.error("âŒ MongoDB connection error:", err));

/**
 * GET /api/city-weather?city=CityName
 * Uses OpenWeatherMap API to fetch weather info and city coordinates.
 */
app.get("/api/city-weather", async (req, res) => {
  const city = req.query.city;
  if (!city) return res.status(400).json({ error: "City is required" });
  try {
    const url = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${openWeatherKey}&units=metric`;
    const response = await axios.get(url);
    const data = response.data;
    res.json({
      name: data.name,
      temp: data.main.temp,
      description: data.weather[0].description,
      coord: data.coord // { lat, lon }
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to fetch weather data" });
  }
});

/**
 * GET /api/heatmap-data?city=CityName
 * Dynamically generates heatmap points around the searched city's coordinates.
 */
app.get("/api/heatmap-data", async (req, res) => {
  const city = req.query.city;
  if (!city) return res.status(400).json({ error: "City is required" });

  try {
    const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${openWeatherKey}&units=metric`;
    const response = await axios.get(weatherUrl);
    const coord = response.data.coord;

    const heatData = [];
    for (let i = 0; i < 5; i++) {
      const offsetLat = (Math.random() - 0.5) * 0.1;
      const offsetLon = (Math.random() - 0.5) * 0.1;
      heatData.push({
        lat: coord.lat + offsetLat,
        lon: coord.lon + offsetLon,
        intensity: Math.random() * 2 + 35
      });
    }
    res.json(heatData);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to fetch heatmap data" });
  }
});

/**
 * GET /api/reviews?city=CityName
 * Retrieve reviews for a specific city from MongoDB.
 */
app.get("/api/reviews", async (req, res) => {
  const city = req.query.city;
  if (!city) return res.status(400).json({ error: "City is required" });
  try {
    const reviews = await db.collection("Reviews").find({ city }).toArray();
    res.json(reviews);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to fetch reviews" });
  }
});

/**
 * POST /api/reviews
 * Submit a new review.
 */
app.post("/api/reviews", async (req, res) => {
  const { city, text, rating } = req.body;
  if (!city || !text || !rating)
    return res.status(400).json({ error: "City, text, and rating are required" });
  try {
    const result = await db.collection("Reviews").insertOne({
      city,
      text,
      rating,
      timestamp: new Date()
    });
    res.json({ success: true, reviewId: result.insertedId });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to submit review" });
  }
});

/**
 * DELETE /api/reviews/:id
 * Delete a review by its ID.
 */
app.delete("/api/reviews/:id", async (req, res) => {
  const id = req.params.id;
  try {
    const result = await db.collection("Reviews").deleteOne({ _id: new ObjectId(id) });
    if (result.deletedCount === 1) {
      res.json({ success: true });
    } else {
      res.status(404).json({ error: "Review not found" });
    }
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to delete review" });
  }
});

/**
 * GET /api/properties?city=CityName
 * Returns 3 sample properties in a nonâ€“heat zone area. 
 * This is generated by fetching the city's coordinates via OpenWeatherMap
 * and then generating property data with larger offsets.
 */
app.get("/api/properties", async (req, res) => {
  const city = req.query.city;
  if (!city) return res.status(400).json({ error: "City is required" });
  try {
    const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${openWeatherKey}&units=metric`;
    const response = await axios.get(weatherUrl);
    const coord = response.data.coord;
    
    const properties = [];
    for (let i = 0; i < 3; i++) {
      // Use a larger offset (e.g., around +0.2 degrees) to simulate a nonâ€“heat zone area.
      const offsetLat = (Math.random() - 0.5) * 0.1 + 0.2;
      const offsetLon = (Math.random() - 0.5) * 0.1 + 0.2;
      properties.push({
        id: i + 1,
        name: `Property ${i + 1}`,
        price: Math.floor(Math.random() * 100000) + 50000, // price between 50k - 150k
        lat: coord.lat + offsetLat,
        lon: coord.lon + offsetLon,
        address: `Address ${i + 1}, ${city}`
      });
    }
    res.json(properties);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to fetch properties" });
  }
});

/**
 * GET /api/green-suggestions
 * Retrieve green suggestion zones.
 */
app.get("/api/green-suggestions", async (req, res) => {
  try {
    const suggestions = await db.collection("GreenSuggestions").find().toArray();
    res.json(suggestions);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to fetch green suggestions" });
  }
});

/**
 * POST /api/green-suggestions
 * Submit a new green suggestion.
 */
app.post("/api/green-suggestions", async (req, res) => {
  const { lat, lng, reason } = req.body;
  if (!lat || !lng || !reason)
    return res.status(400).json({ error: "Latitude, longitude and reason are required" });
  try {
    const result = await db.collection("GreenSuggestions").insertOne({
      lat,
      lng,
      reason,
      timestamp: new Date()
    });
    res.json({ success: true, suggestionId: result.insertedId });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to submit suggestion" });
  }
});

/**
 * GET /api/tree-zones?city=CityName
 * Returns suggested locations for planting trees.
 */
app.get('/api/tree-zones', (req, res) => {
  const city = req.query.city;
  if (!city) return res.status(400).json({ error: "City is required" });

  const treeZones = {
    "Nagpur": [
      { lat: 21.1458, lon: 79.0882, description: "Near Gandhisagar Lake - ample open space" },
      { lat: 21.1482, lon: 79.0736, description: "Open field behind VNIT Campus" }
    ],
    "New York": [
      { lat: 40.7128, lon: -74.0060, description: "Battery Park open ground" },
      { lat: 40.7306, lon: -73.9866, description: "East River Park greenbelt" }
    ]
    // Add more cities if desired
  };

  res.json(treeZones[city] || []);
});

/**
 * GET /api/residences?city=CityName
 * Returns available residential options in the specified city.
 */
app.get('/api/residences', (req, res) => {
  const city = req.query.city;
  if (!city) return res.status(400).json({ error: "City is required" });

  const residences = {
    "Nagpur": [
      { name: "Orange City Heights", address: "Wardha Road" },
      { name: "MIHAN Residency", address: "MIHAN Zone" },
      { name: "Civil Lines Apartments", address: "Civil Lines Area" }
    ],
    "New York": [
      { name: "Central Park Towers", address: "5th Avenue" },
      { name: "East Side Lofts", address: "East 63rd Street" }
    ]
    // Add more cities as needed
  };

  res.json(residences[city] || []);
});